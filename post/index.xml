<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Cheng Blog</title>
    <link>https://luckyliang.github.io/post/</link>
    <description>Recent content in Posts on Cheng Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 24 Oct 2018 23:32:00 +0000</lastBuildDate>
    
	<atom:link href="https://luckyliang.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>go 操作 mysql</title>
      <link>https://luckyliang.github.io/2018/10/24/goopmysql/</link>
      <pubDate>Wed, 24 Oct 2018 23:32:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/10/24/goopmysql/</guid>
      <description>使用Go操作MySQL等数据库，一般有两种方式：一是使用database/sql接口，直接在代码里硬编码sql语句；二是使用gorm，即对象</description>
    </item>
    
    <item>
      <title>MySQL基本使用方法</title>
      <link>https://luckyliang.github.io/2018/10/23/mysqlleaning/</link>
      <pubDate>Tue, 23 Oct 2018 23:32:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/10/23/mysqlleaning/</guid>
      <description>MySQL基本使用 安装就不介绍了，网上多的很，这里主要参考官方文档，记录简单用法 MySQL连接和断开 连接mysql mysql -h host -u user -p Enter password: ******** host 连接的</description>
    </item>
    
    <item>
      <title>RXSwift - 原理分析</title>
      <link>https://luckyliang.github.io/2018/04/23/swiftrxsiwft1/</link>
      <pubDate>Mon, 23 Apr 2018 13:20:22 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/23/swiftrxsiwft1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Swift - PromisKit使用</title>
      <link>https://luckyliang.github.io/2018/04/21/swiftpromiskit/</link>
      <pubDate>Sat, 21 Apr 2018 16:30:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/21/swiftpromiskit/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Moya - 源码解析</title>
      <link>https://luckyliang.github.io/2018/04/20/swifturlmoyadetail/</link>
      <pubDate>Fri, 20 Apr 2018 20:31:08 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/20/swifturlmoyadetail/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Swift网络请求 - RXSwift &#43; PromiseKit &#43; Moya</title>
      <link>https://luckyliang.github.io/2018/04/20/swifturlmoya/</link>
      <pubDate>Fri, 20 Apr 2018 16:30:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/20/swifturlmoya/</guid>
      <description>Moya是基于Alamofire网络框架上进行的封装，支持RXSwift 创建模型 import Foundation /// 实用泛行实现通用格式 public struct ResponseData&amp;lt;T&amp;gt;: Codable where T: Codable { let code: String let message: String let data: T?</description>
    </item>
    
    <item>
      <title>Alamofire源码解析</title>
      <link>https://luckyliang.github.io/2018/04/19/swifturlalamofiredetail/</link>
      <pubDate>Thu, 19 Apr 2018 16:30:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/19/swifturlalamofiredetail/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Siwft网络请求 - Alamofire</title>
      <link>https://luckyliang.github.io/2018/04/18/swifturlalamofire/</link>
      <pubDate>Wed, 18 Apr 2018 20:30:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/18/swifturlalamofire/</guid>
      <description>一个简单的get请求接口为例，搭建一个比较完整的网络框架，其中包括Session管理，路由和错误处理 这里以获取用户文章列表接口为例 创建模型 ///</description>
    </item>
    
    <item>
      <title>Siwft网络请求 - URLSession</title>
      <link>https://luckyliang.github.io/2018/04/18/swifturlsession/</link>
      <pubDate>Wed, 18 Apr 2018 19:40:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/18/swifturlsession/</guid>
      <description>URLSession功能 NSURLSession 支持 http2.0 协议 在处理下载任务的时候可以直接把数据下载到磁盘 支持后台下载与上传 同一个 session 发送多个请求，只需要建立一次连接（</description>
    </item>
    
    <item>
      <title>Siwft 小技巧记录</title>
      <link>https://luckyliang.github.io/2018/04/18/swifttipsrecord/</link>
      <pubDate>Wed, 18 Apr 2018 19:22:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/18/swifttipsrecord/</guid>
      <description>Swift 记录 通过字符串初始化类 比如有个类名为URLSessionViewController，在Swift中通过字符串来初始化 ///规则：项目名.</description>
    </item>
    
    <item>
      <title>go 错误收集</title>
      <link>https://luckyliang.github.io/2018/04/12/goerror/</link>
      <pubDate>Thu, 12 Apr 2018 19:32:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/12/goerror/</guid>
      <description>ListenAndServe: listen tcp: address 3000: missing port in address exit status 1 学习go net/http包，代码如下 func getNews(writer http.ResponseWriter, request *http.Request) { writer.Write([]byte(&amp;quot;hello&amp;quot;)) } func main() { http.HandleFunc(&amp;quot;/getNews&amp;quot;,getNews) log.Println(&amp;quot;Listening....&amp;quot;) err := http.ListenAndServe(&amp;quot;3000&amp;quot;,nil) if err != nil { log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err) } } 执行命令 $ go run main.go</description>
    </item>
    
    <item>
      <title>IOS底层原理一  探寻OC对象本质</title>
      <link>https://luckyliang.github.io/2018/04/11/iosunderlying_ocobjectessence/</link>
      <pubDate>Wed, 11 Apr 2018 09:32:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/04/11/iosunderlying_ocobjectessence/</guid>
      <description>IOS底层原理总结 - 探寻oc对象的本质 面试题：一个NSObject对象占用多少内存？ 探寻OC对象的本质，我们平时编写的Objective-C</description>
    </item>
    
    <item>
      <title>go - 处理web请求</title>
      <link>https://luckyliang.github.io/2018/03/13/gorequest/</link>
      <pubDate>Tue, 13 Mar 2018 19:25:21 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/03/13/gorequest/</guid>
      <description>web应用非常重要的功能之一就是接受来自客户端发起的请求，然后返回数据以完成与客服端的数据交互，这篇文章主要记录go在处理这些数据请求时常用</description>
    </item>
    
    <item>
      <title>go - httprouter高性能Http框架</title>
      <link>https://luckyliang.github.io/2018/03/12/gohttprouter/</link>
      <pubDate>Mon, 12 Mar 2018 20:35:23 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/03/12/gohttprouter/</guid>
      <description>安装 HttpRouter go get github.com/julienschmidt/httprouter 认识httprouter package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;github.com/julienschmidt/httprouter&amp;quot; ) func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) { fmt.Fprint(w, &amp;quot;Welcome!\n&amp;quot;) } func main() { router := httprouter.New() router.GET(&amp;quot;/&amp;quot;, Index) log.Fatal(http.ListenAndServe(&amp;quot;:3000&amp;quot;, router)) } 执行go run main.go 然后在浏览器输入http://</description>
    </item>
    
    <item>
      <title>go - net/http的简单使用</title>
      <link>https://luckyliang.github.io/2018/03/10/gonet/</link>
      <pubDate>Sat, 10 Mar 2018 20:32:40 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/03/10/gonet/</guid>
      <description>Go 语言中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler。 ServrMux：本质上是一个 HTTP 请求路由器,它把收到的请求与一组预先</description>
    </item>
    
    <item>
      <title>NASM 环境搭建</title>
      <link>https://luckyliang.github.io/2018/02/11/nasminstall/</link>
      <pubDate>Sun, 11 Feb 2018 09:32:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/11/nasminstall/</guid>
      <description>一. 安装NASM NASM网站： https://www.nasm.us/ 点击Downloads 到下载页面，下载最新安装包 点击展开包，点击x x x.tar.gz包 下载 双击下载的包解压，</description>
    </item>
    
    <item>
      <title>Go 学习笔记（七） - 错误处理</title>
      <link>https://luckyliang.github.io/2018/02/09/goerror/</link>
      <pubDate>Fri, 09 Feb 2018 19:35:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/09/goerror/</guid>
      <description>错误指出程序中的异常情况。假设我们正在尝试打开一个文件，文件系统中不存在这个文件。这是一个异常情况，它表示为一个错误。 Go中的错误也是一种类</description>
    </item>
    
    <item>
      <title>Go 学习笔记（六） - 接口</title>
      <link>https://luckyliang.github.io/2018/02/08/gointerface/</link>
      <pubDate>Thu, 08 Feb 2018 22:45:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/08/gointerface/</guid>
      <description>在Go中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。 接口的定义语法 定义接口 /* 定义接口 */ type interface_name interface { method_name1 [return_type] method_name2 [return_type] method_name3 [return_type] ...</description>
    </item>
    
    <item>
      <title>Go 学习笔记（五） - 方法</title>
      <link>https://luckyliang.github.io/2018/02/08/gomethod/</link>
      <pubDate>Thu, 08 Feb 2018 18:42:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/08/gomethod/</guid>
      <description>方法声明 package geometry import &amp;quot;math&amp;quot; type Point struct{ X, Y float64 } // traditional function func Distance(p, q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } // same thing, but as a method of the Point type func (p Point) Distance(q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } 在方法调用过程中，接收器参数一般会在方法</description>
    </item>
    
    <item>
      <title>Go 学习笔记（四） - 函数</title>
      <link>https://luckyliang.github.io/2018/02/07/gofunc/</link>
      <pubDate>Wed, 07 Feb 2018 23:12:34 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/07/gofunc/</guid>
      <description>函数 函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func name(parameter-list) (result-list) { body } 返回值列表描述了函数返回值的变量名以及类型，如果一</description>
    </item>
    
    <item>
      <title>Go 学习笔记（三） - 复合类型</title>
      <link>https://luckyliang.github.io/2018/02/06/gocomplextype/</link>
      <pubDate>Tue, 06 Feb 2018 20:39:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/06/gocomplextype/</guid>
      <description>复合数据类型 数组 数组是一个由固定长度的特定类型元素组成的序列，因为数组的长度是固定的，因此在Go语言中很少直接使用数组 数组的每个元素可以通过</description>
    </item>
    
    <item>
      <title>Go 学习笔记（二） - 基础数据类型</title>
      <link>https://luckyliang.github.io/2018/02/05/gobasetype/</link>
      <pubDate>Mon, 05 Feb 2018 21:32:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/05/gobasetype/</guid>
      <description>基础数据类型 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。 基础类型：数字、字符串和布尔型等 复合数据类型：数组和结构体，</description>
    </item>
    
    <item>
      <title>Go 学习笔记（一） - 程序结构</title>
      <link>https://luckyliang.github.io/2018/02/05/gostructure/</link>
      <pubDate>Mon, 05 Feb 2018 19:32:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/2018/02/05/gostructure/</guid>
      <description>程序结构 命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Uni</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckyliang.github.io/post/ios/swift-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckyliang.github.io/post/ios/swift-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/</guid>
      <description>序列  Sequence 协议是集合类型结构中的基础。 一个序列 (sequence) 代表的是一系列具有相同类型 的值，你可以对这些值进行迭代。
 for element in someSequence { doSomething(with: element) }  满足 Sequence 协议的要求十分简单，你需要做的所有事情就是提供一个返回迭代器 (iterator) 的 makeIterator() 方法:
protocol Sequence { associatedtype Iterator: IteratorProtocol func makeIterator() -&amp;gt; Iterator // ... }  迭代器 序列通过创建一个迭代器来提供对元素的访问。 迭代器每次产生一个序列的值，并且当遍历序 列时对遍历状态进行管理。在 IteratorProtocol 协议中唯一的一个方法是 next()，这个方法需 要在每次被调用时返回序列中的下一个值。当序列被耗尽时，next() 应该返回 nil:
protocol IteratorProtocol { associatedtype Element mutating func next() -&amp;gt; Element? }  for 循环其实是下面这段代码 的一种简写形式:
var iterator = someSequence.makeIterator() while let element = iterator.</description>
    </item>
    
  </channel>
</rss>